---
title: "STAT 598: Assignment 3"

output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r }
library(splines)
library(dplyr)
library(tidyverse)
options(digits = 4)
set.seed(0939)
```

# Part I

```{r }
myData = read.csv("Coding3_Data_Original.csv")
x = myData$x
y = myData$y

fx = 1:100/100;
fy = sin(12*(fx+0.2))/(fx+0.2)

```


### Local regression with LOESS.

```{r }
smooth.diagonal = function(x, span){
# return the smoother matrix with values x and span = span
# 
 n = length(x)
 A = matrix(0, n, n)
 for(i in 1:n){
       y = rep(0, n); y[i]=1
       yi = loess(y ~ x, data.frame(x, y), span=span)$fitted
       A[,i]= yi
       }
 return(diag(A))
}

S = smooth.diagonal(x, span = 0.5)


```


```{r }
spans = seq(0.2,0.9, by = 0.05)

m = length(spans)
n = length(x)

mycv = rep(0,m)
mygcv = rep(0,m)

for (i in 1:m) {
  S = smooth.diagonal(x, span = spans[i])
  mean_S = mean(S)
  fit = loess(y ~ x, myData, span=spans[i])
  mycv[i] = sum(((y-fit$fitted)/(1-S))^2)/n
  mygcv[i] = sum((y-fit$fitted)^2)/(1-mean_S)^2/n
}
  
optspan.gcv = spans[mygcv==min(mygcv)]
optspan.cv = spans[mycv==min(mycv)]

fitopt = loess(y ~ x, myData, span=optspan.cv)

```



```{r }

plot(x, y, xlab="x", ylab="y")
lines(fx, predict(fitopt, fx), col="red", lwd=2)
lines(fx, fy, col="gray", lwd=2)  

```

# Part II
```{r}
sales = read.csv('Sales_Transactions_Dataset_Weekly.csv')[,c(1:53)] %>% 
  data.frame()

# Normalize time series by removing means -----------
# Store as 811 x 52 matrix
sales_norm = sales %>% 
  mutate(means = rowMeans(select(., starts_with('W')), na.rm=T)) %>% 
  mutate(across(c(-c('Product_Code', 'means')), ~ . - means)) %>% 
  select(-means) %>% 
  column_to_rownames('Product_Code') %>% 
  as.matrix()  
```

### 1. Fitting NCS

```{r}
# 1. Fitting NCS 
n.knots = 8
df = 9
x = seq(0, 52, length.out= ncol(sales_norm))

## F is a 52-by-9 design matrix without the intercept. For instance, this can be obtained using
# the ns command in R. Remove the column mean from F to disregard the intercept.
mat_F1 = ns(x, df=9, intercept=FALSE)
mat_F = t(t(mat_F1) - colMeans(mat_F1)) 

# Get B using provided matrix equation and mat_F
eq1 = solve(t(mat_F)%*%mat_F)
B_transpose = eq1%*%t(mat_F)%*%t(sales_norm)
mat_B = t(B_transpose)
```

## Clustering
```{r}
plot_function <- function(df, i, matrix = 'B'){
  matplot(df, type='l', col='grey', pch=20, xlab='Weeks', ylab='Weekly Sales',
          ylim = c(-20,30))
  if (matrix == 'B'){
    # use matrix product Fb
    matlines(mat_F%*%Bcenters[i,], type='l', col='red', lwd=1, lty=1) 
  }
  else{
    matlines(rowMeans(df), type='l', col='red', lwd=1, lty=1) 
  }
}
```

### 2. Clustering Using Matrix B 

```{r}
# K-means on matrix B with 6 clusters
kmeans_B = kmeans(mat_B, centers = 6, nstart=5)
Bclusters = kmeans_B$cluster
Bcenters = kmeans_B$centers
```

```{r}
par(mfrow=c(2,3))
for (i in 1:6){
  pick_cluster= which(Bclusters==i)
  plot_data = matrix(0,52,length(pick_cluster))

  for (j in 1:length(pick_cluster)){
    plot_data[,j] = sales_norm[j,]
  }

  plot_data_final = as.data.frame(plot_data) 
  names(plot_data_final) = gsub(pattern="V", replacement="", x=names(plot_data_final))

  plot_function(plot_data_final, i, matrix='B')
}
```

### 3. Clustering Using Matrix X
```{r}
kmeans_X = kmeans(sales_norm, centers = 6, nstart=5)
Xclusters = kmeans_X$cluster
Xcenters = kmeans_X$centers
```

```{r}
par(mfrow=c(2,3))
for (i in 1:6){
  pick_cluster= which(Xclusters==i)
  plot_data = matrix(0,52,length(pick_cluster))

  for (j in 1:length(pick_cluster)){
    plot_data[,j] = sales_norm[j,]
  }

  plot_data_final = as.data.frame(plot_data)

  plot_function(plot_data_final, i, matrix='X')
}
```
